Unix is an \indexacf{OS}, that is, a layer of software
between the user or a user program and the hardware. It takes care of
files and screen output, and it makes sure that many processes can exist
side by side on one system. However, it is not immediately visible to
the user.
%
Most of the time that you use Unix, you are typing commands which are
executed by an interpreter called the \indexterm{shell}. The shell
makes the actual \ac{OS} calls. There are a few possible Unix shells
available, but in this tutorial we will assume that you are using the
\indexterm{sh} or \indexterm{bash} shell, although many commands are
common to the various shells in existence.

This short tutorial will get you going; 
if you want to learn more about Unix and shell scripting,
see for instance~\url{http://www.tldp.org/guides.html}.

\Level 0 {Files and such}

\begin{purpose}
In this section you will learn about the Unix file system, which
consists of \indexterm{directories} that store \indexterm{files}. You
will learn about \indexterm{executable} files and commands for
displaying data files.
\end{purpose}

\Level 1 {Looking at files}

\begin{purpose}
In this section you will learn commands for displaying file contents.
\end{purpose}

The \n{ls} command gives you a listing of files that are in your
present location. 

\practical
{Type \n{ls}. Does anything show up?}
{If there are files in your directory, they will be \n{l}i\n{s}ted; if
  there are none, no output will be given. This is standard Unix
  behaviour: no output does not mean that something went wrong, it
  only means that there is nothing to report.}{}

The \n{cat} command is often used to display files, but it can also be
used to create some simple content. 

\practical
{Type \n{cat > newfilename} (where you can pick any
  filename) and type some text. Conclude with \n{Control-d} on a line by itself.
Now use \n{cat} to view the contents of that file: \n{cat newfilename}.}
{In the first use of \n{cat}, text was con\n{cat}enated from the
  terminal to a file; in the second the file was cat'ed to the
  terminal output. You should see on your screen precisely what you
  typed into the file.}
{Be sure to type \n{Control-d} as the first thing on the last line of input. If you
  really get stuck, \n{Control-c} will usually get you out. Try this:
  start creating a file with \n{cat > filename} and hit \n{Control-c} in
  the middle of a line. What are the contents of your file?}

Above you used \n{ls} to get a directory listing. You can also use the
\n{ls} command on specific files: 

\practical
{Do \n{ls newfilename} with the file that you created above; also do
  \n{ls nosuchfile} with a file name that does not exist.}
{For an existing file you get the file name on your screen; for a
  non-existing file you get an error message.}
{}

The \n{ls} command can give you all sorts of information.

\practical {Read the man page of the \n{ls} command: \n{man ls}. Find
  out the size and creation date of some files, for instance the file
  you just created.}  
{Did you find the \n{ls -s} and \n{ls -l}
  options? The first one lists the size of each file, usually in
  kilobytes, the other gives all sorts of information about a file,
  including things you will learn about later.}  
{The \n{man} command
  puts you in a mode where you can view long text documents. This
  viewer is common on Unix systems (it is available as the \n{more} or
  \n{less} system command), so memorize the following ways of navigating: Use
  the space bar to go forward and the \n{u} key to go back up. Use
  \n{g} to go to the beginning fo the text, and \n{G} for the end. Use
  \n{q} to exit the viewer. If you really get stuck, \n{Control-c} will
  get you out.}

(If you already know what command you're looking for, you can use man
to get online information about it. If you forget the name of a
command, \n{man -k keyword} can help you find it.)

The \n{touch} command creates an empty file, updates the timestamp of
a file if it already exists. Use \n{ls -l} to confirm this behaviour.

Three more useful commands for files are: \n{cp} for copying, \n{mv}
(short for `move') for renaming, and \n{rm} (`remove') for deleting.
Experiment with them.

There are more commands for displaying a file, parts of a file, or
information about a file. 

\practical{Do \n{ls /usr/share/words} or \n{ls
  /usr/share/dict/words} to confirm that a file with words exists on
your system. Now experiment with the commands \n{head}, \n{tail},
\n{more}, and
\n{wc} using that file.}
{\n{head} displays the first couple of lines of a file, \n{tail} the
  last, and \n{more} uses the same viewer that is used for man
  pages. Read the man pages for these commands and experiment with
  increasing and decreasing the amount of output. 
  The \n{wc} (`word count') command reports the number of words,
  characters, and lines in a file.}{}

\Level 1 {Directories}

\begin{purpose}
  Here you will learn about the Unix directory tree, how to manipulate
  it and how to move around in it.
\end{purpose}

A unix file system is a tree of directories, where a directory is a
container for files or more directories. We will display directories
as follows:

\dirdisplay{.1 /\DTcomment{The root of the directory tree}. 
.2 bin\DTcomment{Binary programs}. .2 home\DTcomment{Location of
    users directories}. }

The root of the Unix directory tree is indicated with a slash. Do
\n{ls /} to see what the files and directories there are in the
root. Note that the root is not the location where you start when you
reboot your personal machine, or when you log in to a server.

\practical
{The command to find out your current working directory
is \n{pwd}. Your home directory is your working directory immediately
when you log in. Find out your home directory.}
{You will typically see something like \n{/home/yourname} or
  \n{/Users/yourname}. This is system dependent.}{}

Do \n{ls} to see the contents of the working directory. In the
displays in this section, directory names will be followed by a
slash:~\n{dir/} but this character is not part of their name.  You can
get this output by using \n{ls -F}, and you can tell your shell to
use this output consistently by stating \n{alias ls=ls -F} at the start of your
session. Example:

\dirdisplay{.1 /home/you/. .2 adirectory/. .2 afile. }

The command for making a new directory is \n{mkdir}.

\practical{Make a new directory with \n{mkdir newdir} and view the
  current directory with \n{ls}}
{You should see this structure:
\dirdisplay{.1 /home/you/. .2 newdir/\DTcomment{the new directory}. }
}{}

The command for going into another directory, that is, making it your
working directory, is \n{cd} (`change directory'). It can be used in
the following ways:
\begin{itemize}
\item \n{cd} Without any arguments, \n{cd} takes you to your home directory.
\item \n{cd <absolute path>} An absolute path starts at the root of
  the directory tree, that is, starts with~\n{/}. The \n{cd} command
  takes you to that location.
\item \n{cd <relative path>} A relative path is one that does not
  start at the root. This form of the \n{cd} command takes you to
  \n{<yourcurrentdir>/<relative path>}.
\end{itemize}

\practical{Do \n{cd newdir} and find out where you are in the
  directory tree with \n{pwd}. 
  Confirm with \n{ls} that the directory is empty.
  How would you get to this location using an absolute path?}
{\n{pwd} should tell you \n{/home/you/newdir}, and \n{ls} then has no
  output, meaning there is nothing to list. 
  The absolute path is \n{/home/you/newdir}.}{}

\practical{Let's quickly create a file in this directory:
\n{touch onefile}, and another directory: \n{mkdir otherdir}.
Do \n{ls} and confirm that there are a new file and directory.}
{You should now have:
\dirdisplay{.1 /home/you/. .2 newdir/\DTcomment{you are here}. 
.3 onefile. .3 otherdir/. }}{}

The \n{ls} command has a very useful option: with \n{ls -a} you see
your regular files and hidden files, which have a name that starts
with a dot. Doing \n{ls -a} in your new directory should tell you that
there are the following files:

\dirdisplay{.1 /home/you/. .2 newdir/\DTcomment{you are here}. 
.3 .. .3 ... .3 onefile. .3 otherdir/. }

The single dot is the
current directory, and the double dot is the directory one level
back. 

\practical{Predict where you will be after \n{cd ./otherdir/..}  and
  check to see if you were right.}
{The single dot sends you to the current directory, so that does not
  change anything. The \n{otherdir} part makes that subdirectory your
  current working directory. Finally, \n{..} goes one level back. In
  other words, this command puts your right back where you started.}{}

Since your home directory is a special place, there are shortcuts for
\n{cd}'ing to it: \n{cd} without arguments, \n{cd ~}, and \n{cd \$HOME}
  all get you back to your home.

Go to your home directory, and from there do \n{ls newdir} to check
the contents of the first directory you created, without having to go
there.

\practical
{What does \n{ls ..} do?}
{Recall that \n{..} denotes the
  directory one level up in the tree: you should see your own home
  directory, plus the directories of any other users.}{}

\practical
{Can you use \n{ls} to see the
contents of someone else's home directory? In the previous exercise
  you saw whether other users exist on your system. If so, do \n{ls
    ../thatotheruser}.}
{If this is your private computer, you can
  probably view the contents of the other user's directory. If this is
  a university computer or so, the other directory may very well be
  protected --~permissions are discussed in the next section~-- and
  you get \n{ls: ../otheruser: Permission denied}.}{}

Make an attempt to move into someone else's home directory with
\n{cd}. Does it work?

You can make copies of a directory with \n{cp}, but you need to add a
flag to indicate that you recursively copy the contents: \n{cp
  -r}. Make another directory \n{somedir} in your home so that you have

\dirdisplay{.1 /home/you/. .2 newdir/\DTcomment{you have been working
    in this one}. 
.2 somedir/\DTcomment{you just created this one}. }

What is the difference between \n{cp -r newdir
  somedir} and \n{cp -r newdir thirddir} where \n{thirddir} is not an
existing directory name?

\Level 1 {Permissions}

\begin{purpose}
  In this section you will learn about how to give various users on
  your system permission to do (or not to do) various things with your
  files.
\end{purpose}

Unix files, including directories,
have permissions, indicating `who can do what with this
file'. Actions that can be performed on a file fall into three
categories:
\begin{itemize}
\item reading \n{r}: any access to a file (displaying, getting information
  on it) that does not change the file;
\item writing \n{w}: access to a file that changes its content, or even its
  metadata such as `date modified';
\item executing \n{x}: if the file is executable, to run it; if it is a
  directory, to enter it.
\end{itemize}
The people who can potentially access a file are divided into three
classes too:
\begin{itemize}
\item the user \n{u}: the person owning the file;
\item the group \n{g}: a group of users to which the owner belongs;
\item other \n{o}: everyone else.
\end{itemize}
These nine permissions are rendered in sequence
\[ \begin{array}{|c|c|c|}
  \hline user&group&other\\ \hline rwx&rwx&rwx \\ \hline
\end{array}
\]
For instance
\n{rw-r--r--} means that the owner can read and write a file, the owner's
group and everyone else can only read. 

Permissions are also rendered
numerically in groups of three bits, by letting $\n{r}=4$, $\n{w}=2$,
$\n{x}=1$:
\[ \begin{array}{|c|}
  \hline rwx\\ \hline 421 \\ \hline
\end{array}
\]
Common codes are $7=\n{rwx}$ and $6=\n{rw}$. You will find
many files that have permissions $755$ which stands for an executable
that everyone can run, but only the owner can change, or $644$ which
stands for a data file that everyone can see but again only the owner
can alter. You can set permissions by 
\begin{verbatim}
  chmod <permissions> file         # just one file
  chmod -R <permissions> directory # directory, recursively
\end{verbatim}
Examples:
\begin{verbatim}
  chmod 766 file  # set to rwxrw-rw-
  chmod g+w file  # give group write permission
  chmod g=rx file # set group permissions
  chod o-w  file  # take away write permission from others
  chmod o=  file  # take away all permissions from others.
  chmod g+r,o-x file # give group read permission
                     # remove other execute permission
\end{verbatim}
The man page gives all options.

\practical
{Make a file \n{foo} and do \n{chmod u-r foo}. Can you now inspect its
contents? Make the file readable again, this time using a numeric
code. Now make the file readable to your classmates. Check by having
one of them read the contents.}
{When you've made the file `unreadable'
  by yourself, you can still \n{ls} it, but not \n{cat} it: that will
  give a `permission denied' message.}{}

Make a file \n{com} with the following contents:
\begin{verbatim}
#!/bin/sh
echo "Hello world!"
\end{verbatim}
This is a legitimate shell script. What happens when you type
\n{./com}? Can you make the script executable?

Adding or taking away permissions can be done with the following
syntax:

\Level 1 {Wildcards}
\label{sec:shell-wildcard}

You already saw that \n{ls filename} gives you information about that
one file, and \n{ls} gives you all files in the current directory. To
see files with certain conditions on their names, the
\indexterm{wildcard} mechanism exists. The following wildcards exist:
\begin{itemize}
\item [\n{*}] any number of characters.
\item [\n{?}] any character.
\end{itemize}
Example:
\begin{verbatim}
%% ls
s       sk      ski     skiing  skill
%% ls ski*
ski     skiing  skill
\end{verbatim}
The second option lists all files whose name start with
\n{ski}, followed by any number of other characters'; below you will
see that in different contexts \n{ski*} means `\n{sk} followed by any
number of \n{i} characters'. Confusing, but that's the way it is.

\Level 0 {Text searching and regular expressions}

\begin{purpose}
  In this section you will learn how to search for text in files.
\end{purpose}

For this section you need at least one file that contains some amount
of text. You can for instance get random text from
\url{http://www.lipsum.com/feed/html}. 

The \n{grep} command can be used to search for a text expression in a
file.

\practical{Search for the letter \n{q} in your text file with \n{grep
    q yourfile} and search for it in all files in your directory with
  \n{grep q *}. Try some other searches.}
{In the first case, you get a listing of all lines that contain
  a~\n{q}; in the second case, \n{grep} also reports what file name
  the match was found in: \n{qfile:this line has q in it}.}
{If the string you are looking for does not occur, \n{grep} will
  simply not output anything. Remember that this is standard behaviour
for Unix commands if there is nothing to report.}

In addition to searching for literal strings, you can look for more
general expressions.

\begin{tabular}{|l|l|} 
  \hline
  \verb+^+&the beginning of the line\\
  \verb+$+&the end of the line\\
  \verb+.+&any character\\
  \verb+*+&any number of repetitions \\
  \verb+[xyz]+&any of the characters \n{xyz}\\
  \hline
\end{tabular}

This looks like the wildcard mechanism you just saw
(section~\ref{sec:shell-wildcard}) but it's subtly different. Compare
the example above with:
\begin{verbatim}
%% cat s
sk
ski
skill
skiing
%% grep "ski*" s
sk
ski
skill
skiing
\end{verbatim}
In the second case you search for a string consisting of \n{sk} and
any number of \n{i} characters, including zero of them.

Some more examples: you can find
\begin{itemize}
\item All lines that contain the letter `q' with \verb+grep q yourfile+;
\item All lines that start with an~`a' with \verb+grep "^a" yourfile+
  (if your search string contains special characters, it is a good
  idea to use quote marks to enclose it);
\item All lines that end with a digit with \verb+grep "[0-9]$" yourfile+.
\end{itemize}

\practical{Construct the search strings for finding
  \begin{itemize}
  \item lines that start with an uppercase character, and
  \item lines that contain exactly one character.
  \end{itemize}
}{For the first, use the range characters \n{[]}, for the second use
  the period to match any character.}{}

\practical{Add a few lines \n{x = 1}, \n{x {} = 2}, \n{x {} {} = 3}
  (that is, have different numbers of spaces between \n{x} and the
  equals sign) to your test file, and
  make \n{grep} commands to search for all assignments
  to~\n{x}.}{}{}

The characters in the table above have special meanings. If you want
to search that actual character, you have to \indexterm{escape} it.

\practical{Make a test file that has both \n{abc} and \n{a.c} in
  it, on separate lines.
  Try the commands \n{grep "a.c" file}, \n{grep a\\.c file},
  \n{grep "a\\.c" file.}}
{You will see that the period needs to be escaped, and the search
  string needs to be quoted. In the absence of either, you will see
  that \n{grep} also finds the \n{abc} string.}{}

\Level 1 {Stream editing with \protect\n{sed}}

Unix has various tools for processing text files on a line-by-line
basis. The stream editor \n{sed} is one example. If you have used the
\n{vi} editor, you are probably used to a syntax like
\verb+s/foo/bar/+ for making changes. With \n{sed}, you can do this on
the commandline. For instance
\begin{verbatim}
sed 's/foo/bar/' myfile > mynewfile
\end{verbatim}
will apply the substitute command \n{s/foo/bar/} to every line of
\n{myfile}. The output is shown on your screen so you should capture
it in a new file; see section~\ref{sec:unixpipe} for more on output
redirection.

\Level 1 {Cutting up lines with \protect\n{cut}}

Another tool for editing lines is \n{cut}, which will cut up a line
and display certain parts of it. For instance,
\begin{verbatim}
cut -c 2-5 myfile
\end{verbatim}
will display the characters in position 2--5 of every line of
\n{myfile}. Make a test file and verify this example.

Maybe more useful, you can give \n{cut} a delimiter character and have
it split a line on occurrences of that delimiter. For instance, your system
will mostly likely have a file \n{/etc/passwd} that contains user
information\footnote{This is traditionally the case; on Mac OS
  information about users is kept elsewhere and this file only
  contains system services.}, with every line consisting of fields
separated by colons. For instance:
\begin{verbatim}
daemon:*:1:1:System Services:/var/root:/usr/bin/false
nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false
root:*:0:0:System Administrator:/var/root:/bin/sh
\end{verbatim}
The seventh and last field is the login shell of the user;
\n{/bin/false} indicates that the user is unable to log in.

You can display users and their login shells with:
\begin{verbatim}
cut -d ":" -f 1,7 /etc/passwd
\end{verbatim}
This tells \n{cut} to use the colon as delimiter, and to print fields
1~and~7.

\Level 0 {Command execution}

\Level 1 {Search paths}
\begin{purpose}
  In this section you will learn how Unix determines what to do when
  you type a command name.
\end{purpose}

If you type a command such as \n{ls}, the shell does not just rely on
a list of commands: it will actually go searching for a program by the
name \n{ls}. This means that you can have multiple different commands
with the same name, and which one gets executed depends on which one
is found first.

\practical{What you may think of as `Unix commands' are often just
  executable files in a system directory. Do \n{which ls}, and do an
  \n{ls -l} on the result}
{The location of \n{ls} is something like \n{/bin/ls}. If you
  \n{ls} that, you will see that it is probably owned by root. Its
  executable bits are probably set for all users.}{}

The locations where unix searches for commands is the `search path',
which is stored in the \indexterm{environment variable} (for more
details see below) \n{PATH}.

\practical{Do \n{echo \$PATH}. Can you find the location of \n{cd}?
  Are there other commands in the same location? Is the current
  directory `\n{.}' in the path? If not, do \n{export
    PATH=".:\$PATH"}. Now create an executable file \n{cd} in the
  current director (see above for the basics), and do \n{cd}.}
{The path will be a list of colon-separated directories,\\ for
  instance \n{/usr/bin:/usr/local/bin:/usr/X11R6/bin}. If the working
  directory is in the path, it will probably be at the end:
  \n{/usr/X11R6/bin:.}  but most likely it will not be there. If you
  put `\n{.}' at the start of the path, unix will find the local
  \n{cd} command before the system one.}{}

Some people consider having the working directory in the path a
security risk. If your directory is writable, someone could put a
malicious script named \n{cd} (or any other system command) in your
directory, and you would execute it unwittingly.

It is possible to define your own commands as aliases of existing
commands.

\practical{Do \n{alias chdir=cd} and convince yourself that now
  \n{chdir} works just like \n{cd}. Do \n{alias rm='rm -i'}; look up
  the meaning of this in the man pages. Some people find this alias a
  good idea; can you see why?}
{The \n{-i} `interactive' option for \n{rm} 
  makes the command ask for confirmation
  before each delete. Since unix does not have a trashcan that needs
  to be emptied explicitly (as on Windows or the Mac OS),
  this can be a good idea.}{}

\Level 1 {Redirection and Pipelines}
\label{sec:unixpipe}

\begin{purpose}
  In this section you will learn how to feed one command into another,
  and how to connect commands to input and output files.
\end{purpose}

So far, the unix commands you have used have taken their input from
your keyboard, or from a file named on the command line; their output
went to your screen. There are other possibilities for providing input
from a file, or for storing the output in a file.

\Level 2 {Input redirection}

The \n{grep} command had two arguments, the second being a file
name. You can also write \n{grep string < yourfile}, where the
less-than sign means that the input will come from the named file,
\n{yourfile}.

\Level 2 {Output redirection}

More usefully, \n{grep string yourfile > outfile} will take what
normally goes to the terminal, and send it to \n{outfile}. The output
file is created if it didn't already exist, otherwise it is
overwritten. (To append, use \n{grep text yourfile >> outfile}.)

\practical{Take one of the grep commands from the previous section,
  and send its output to a file. Check that the contents of the file
  are identical to what appeared on your screen before. Search for a
  string that does not appear in the file and send the output to a
  file. What does this mean for the output file?}
{Searching for a
  string that does not occur in a file gives no terminal output. If
  you redirect the output of this \n{grep} to a file, it gives a zero size
  file. Check this with \n{ls} and \n{wc}.}{}

\Level 2 {Standard files}

Unix has three standard files that handle input and output:
\begin{itemize}
\item [{\tt stdin}] is the file that provides input for processes.
\item [{\tt stdout}] is the file where the output of a process is
  written.
\item [{\tt stderr}] is the file where error output is written.
\end{itemize}
In an interactive session, all three files are connected to the user
terminal. Using input or output redirection then means that the input
is taken or the output sent to a different file than the terminal.

\Level 2 {Command redirection}

Instead of taking input from a file, or sending output to a file, it
is possible to connect two commands together, so that the second takes
the output of the first as input. The syntax for this is
\verb+cmdone | cmdtwo+; this is called a pipeline. For instance,
\verb+grep a yourfile | grep b+ finds all lines that contains both an
\n{a} and a~\n{b}.

\practical{Construct a pipeline that counts how many lines there are
  in your file that contain the string \n{th}. Use the \n{wc} command
  (see above) to do the counting.}
{}{}

There are a few more ways to combine commands. Suppose you want to
present the result of \n{wc} a bit nicely. Type the following command
\begin{verbatim}
echo The line count is wc -l foo
\end{verbatim}
where \n{foo} is the name of an existing file. The way to
get the actual line count echoed is by the backquote:
\begin{verbatim}
echo The line count is `wc -l foo`
\end{verbatim}
Anything in between backquotes is executed before the rest of the
command line is evaluated. The way \n{wc} is used here, it prints the
file name. Can you find a way to prevent that from happening?

\Level 1 {Processes}

The Unix operating system can run many programs at the same time, by
rotating through
the list and giving each only a  fraction of a second to run each time.
The command \n{ps} can tell you everything that is currently running.

\practical{Type \n{ps}. How many programs are currently running? By
  default \n{ps} gives you only programs that you explicitly
  started. Do \n{ps guwax} for a detailed list of everything that is
  running. How many programs are running? How many belong to the root user,
  how many to you?}
{To count the programs belonging to a user, pipe the \n{ps} command
  through an appropriate \n{grep}, which can then be piped to \n{wc}.}
{}

In this long listing of \n{ps}, the second column contains the process
numbers. Sometimes it is useful to have those. The \n{cut} command
explained above can
cut certain position from a line: type \n{ps guwax | cut -c 10-14}.

To get dynamic information about all running processes, use the
\n{top} command. Read the man page to find out how to sort the output
by CPU usage.

When you type a command and hit return, that command becomes, for
the duration of its run, the \indexterm{foreground
  process}. Everything else that is running at the same time is a
\indexterm{background process}.

Make an executable file \n{hello} with the following contents:
\begin{verbatim}
#!/bin/sh
while [ 1 ] ; do
  sleep 2
  date
done
\end{verbatim}
and type \n{./hello}. 

\practical{Type \n{Control-z}. This suspends the foreground
  process. It will give you a number like \n{[1]} or \n{[2]}
  indicating that it is the first or second program that has been
  suspended or put in the background. Now type \n{bg} to put this
  process in the background. Confirm that there is no foreground
  process by hitting return, and doing an \n{ls}.}
{After you put a process in the background, the terminal is available
  again to accept foreground commands. If you hit return, you should
  see the command prompt. However, the background process still keeps
  generating output.}{}

\practical{Type \n{jobs} to see the processes in the current
  session. If the process you just put in the background was number~1,
  type \n{fg \%1}. Confirm that it is a foreground process again.}
{If a shell is executing a program in the foreground, it will not
  accept command input, so hitting return should only produce blank
  lines.}{}

\practical{When you have made the \n{hello} script a foreground
  process again, you can kill it with \n{Control-c}. Try this. Start
  the script up again, this time as \n{./hello \&} which immediately
  puts it in the background. You should also get output along the
  lines of \n{[1] 12345} which tells you that it is the first job you
  put in the background, and that \n{12345} is its process ID. Kill
  the script with \n{kill \%1}. Start it up again, and kill it by
  using the process number.}
{The command \n{kill 12345} using the process number is usually enough
  to kill a running program. Sometimes it is necessary to use \n{kill
    -9 12345}.}{}

\Level 1 {Shell customization}

Above it was mentioned that \n{ls -F} is an easy way to see which
files are regular, executable, or directories; by typing \n{alias
  ls='ls -F'} the \n{ls} command will automatically expanded to \n{ls
  -F} every time it is invoked. If you would like this behaviour in
every login session, you can add the \n{alias} command to your
\n{.profile} file. Other shells than \n{sh}/\n{bash} have other files for such
customizations.

\Level 0 {Scripting}
\label{sec:unix-script}

The unix shells are also programming environments. You will learn more
about this aspect of unix in this section.

\Level 1 {Shell variables}

Above you encountered \n{PATH}, which is an example of an
shell, or environment, variable. These are variables that are known to the shell
and that can be used by all programs run by the shell. You can see the
full list of all variables known to the shell by typing \n{env}. 

You can get the value of a shell variable by prefixing it with
a dollar sign. Type the following two commands and compare the output:
\begin{verbatim}
  echo PATH
  echo $PATH
\end{verbatim}

\practical{Check on the value of the \n{HOME} variable by typing
  \n{echo \$HOME}. Also find the value of \n{HOME} by piping \n{env}
  through \n{grep}.}{}{}

\Level 1 {Control structures}

Like any good programming system, the shell has some control
structures. Their syntax takes a bit of getting used to. (Different
shells have different syntax; in this tutorial we only discuss the
bash shell.

In the bash shell, control structures can be written over several
lines:
\begin{verbatim}
if [ $PATH = "" ] ; then
  echo "Error: path is empty"
fi
\end{verbatim}
or on a single line:
\begin{verbatim}
if [ `wc -l file` -gt 100 ] ; then echo "file too long" ; fi
\end{verbatim}
There are a number of tests defined, for instance \n{-f somefile}
tests for the existence of a file. Change your script so that it will
report \n{-1} if the file does not exist.

There are also loops. A~\n{for} loop looks like
\begin{verbatim}
for var in listofitems ; do
  something with $var
done
\end{verbatim}
This does the following:
\begin{itemize}
\item for each item in \n{listofitems}, the variable \n{var} is set to the
  item, and
\item the loop body is executed.
\end{itemize}
As a simple example:
\begin{verbatim}
   %% for x in a b c ; do echo $x ; done
a
b
c
\end{verbatim}
In a more meaningful example,
here is how you would make backups of all your~\n{.c}
files:
\begin{verbatim}
for cfile in *.c ; do
  cp $cfile $cfile.bak
done
\end{verbatim}
Shell variables can be manipulated in a number of ways.
Execute the following commands to see that you can remove trailing
characters from a variable:
\begin{verbatim}
%% a=b.c
%% echo ${a%.c}
b
\end{verbatim}
With this as a hint, write a loop that renames all your \n{.c} files
to~\n{.x} files.

\Level 1 {Scripting}

It is possible to write programs of unix shell commands. First you
need to know how to put a program in a file and have it be
executed. Make a file \n{script1} containing the following two lines:
\begin{verbatim}
#!/bin/bash
echo "hello world"
\end{verbatim}
and type \n{./script1} on the command line. Result?
Make the file executable and try again.

You can give your script command line arguments. If you want to be
able to call
\begin{verbatim}
./script1 foo bar
\end{verbatim}
you can use variables \verb+$1+,\verb+$2+ et cetera in the script:
\begin{verbatim}
#!/bin/bash

echo "The first argument is $1"
echo "There were $# arguments in all"
\end{verbatim}

Write a script that takes as input a file name argument, and reports how many
lines are in that file.

Edit your script to test whether the file has less than 10 lines
(use the \n{foo -lt bar} test), and if it does, \n{cat} the
file. Hint: you need to use backquotes inside the test.

The number of command line arguments is available as \verb+$#+. Add a
test to your script so that it will give a helpful message if you call
it without any arguments.

\Level 0 {Expansion}
\label{tut:unix-expansion}

The shell performs various kinds of expansion on a command line, that
is, replacing part of the commandline with different text.

Brace expansion:
\begin{verbatim}
%% echo a{b,cc,ddd}e
abe acce addde
\end{verbatim}
This can for instance be used to delete all extension of some base
file name:
\begin{verbatim}
%% rm tmp.{c,s,o}  # delete tmp.c tmp.s tmp.o
\end{verbatim}

Tilde expansion gives your own, or someone else's home directory:
\begin{verbatim}
%% echo ~
/share/home/00434/eijkhout
%% echo ~eijkhout
/share/home/00434/eijkhout
\end{verbatim}

Parameter expansion gives the value of shell variables:
\begin{verbatim}
%% x=5
%% echo $x
5
\end{verbatim}
Undefined variables do not give an error message:
\begin{verbatim}
%% echo $y
\end{verbatim}
There are many variations on parameter expansion. Above you already
saw that you can strip trailing characters:
\begin{verbatim}
%% a=b.c
%% echo ${a%.c}
b
\end{verbatim}
Here is how you can deal with undefined variables:
\begin{verbatim}
%% echo ${y:-0}
0
\end{verbatim}

\begin{comment}
There are ways of doing pattern matching and substitution 
on a variable:
\begin{verbatim}
%% f=x.fort
%% echo ${f%%.fort}
x
%% echo ${f%%.fort}.bak
x.bak
\end{verbatim}
\end{comment}

The backquote mechanism (section~\ref{sec:unixpipe} above)
is known as command substitution:
\begin{verbatim}
%% echo 123 > w
%% cat w
123
%% wc -c w
       4 w
%% if [ `cat w | wc -c` -eq 4 ] ; then echo four ; fi
four
\end{verbatim}

Unix shell programming is very much oriented towards text manipulation, but it 
is possible to do arithmetic. 
Arithmetic substitution tells the shell to treat the expansion of a
parameter as a number:
\begin{verbatim}
%% x=1
%% echo $((x*2))
2
\end{verbatim}

Integer ranges can be used as follows:
\begin{verbatim}
%% for i in {1..10} ; do echo $i ; done
1
2
3
4
5
6
7
8
9
10
\end{verbatim}

\Level 0 {Shell interaction}

Interactive use of Unix, in contrast to script writing
(section~\ref{sec:unix-script}), is a complicated conversation between
the user and the shell. You, the user, type a line, hit return, and
the shell tries to interpret it. There are several cases.
\begin{itemize}
\item Your line contains one full command, such as \n{ls foo}: the
  shell will execute this command.
\item You can put more than one command on a line, separated by
  semicolons: \n{mkdir foo; cd foo}. The shell will execute these
  commands in sequence.
\item Your input line is not a full command, for instance \n{while [
    1]}. The shell will recognize that there is more to come, and use
  a different prompt to show you that it is waiting for the remainder
  of the command.
\item Your input line would be a legitimate command, but you want to
  type more on a second line. In that case you can end your input line
  with a backslash character, and the shell will recognize that it
  needs to hold off on executing your command. In effect, the
  backslash will hide (\indexterm{escape}) the return.
\end{itemize}

When the shell has collected a command line to execute, by using one or
more of your input line or only part of one, as described just now, it
will apply expansion to the command line
(section~\ref{tut:unix-expansion}). It will then interpret the
commandline as a command and arguments, and proceed to invoke that
command with the arguments as found.

There are some subtleties here. If you type \n{ls *.c}, then the shell
will reognize the wildcard character and expand it to a command line,
for instance \n{ls foo.c bar.c}. Then it will invoke the \n{ls}
command with the argument list \n{foo.c bar.c}. Note that \n{ls} does
not receive \n{*.c} as argument! In cases where you do want the unix
command to receive an argument with a wildcard, you need to escape it
so that the shell will not expand it. For instance, \n{find . -name
  \\*.c} will make the shell invoke \n{find} with arguments \n{. -name
  *.c}.

\Level 0 {The system and other users}

If you are on your personal machine, you may be the only user logged
in. On university machines or other servers, there will often be other
users. Here are some commands relating to them.

\begin{itemize}
\item [{\tt whoami}] show your login name
\item [{\tt who}] show the other currently logged in users
\item [{\tt finger otherusername}] get information about another user
\item [{\tt top}] which processes are running on the system; use
  \n{top -u} to get this sorted the amount of cpu time they are
  currently taking. (On Linux, try also the \n{vmstat} command.)
\item [{\tt uptime}] how long has your system been up?
\end{itemize}


\Level 0 {Review questions}

\begin{istc}
\begin{exercise}
    Devise a pipeline that counts how many users are logged onto
    the system, whose name starts with a vowel and ends with a
    consonant.
\end{exercise}
\end{istc}

\begin{exercise}
Write a shell script for making backups. When you call this script as
\n{./backup somefile} it should test whether \n{somefile.bak} exists,
and give a warning if it does. In either case, it should copy the 
original file to a backup.
\end{exercise}

%\Level 0 {Unix tools}

%Sed, awk

