{applications,approximation,discrete,namd,performance,programming}.texMost of the time, a program is written is written in a single
language, but in some circumstances it is necessary or desirable to
mix sources in more than one language for a single executable. One
such case is when a library is written in one language, but used by a
program in another. In such a case, the library writer will probably
have made it easy for you to use the library; this section is for the
case that you find yourself in the place of the library writer. We
will focus on the common case of interfacing between C/C++ and
Fortran.

\Level 0 {Arrays}
\label{sec:arrays}

C and Fortran have different conventions for storing multi-dimensional
arrays. You need to be aware of this when you pass an array between
routines written in different languages. 

Fortran stores multi-dimensional arrays in \indexterm{column-major}
order. For two dimensional arrays (\texttt{A(i,j)}) this means that
the elements in each column are stored contiguously: a $2\times2$
array is stored as \texttt{A(1,1), A(2,1), A(1,2), A(2,2)}. Three and
higher dimensional arrays are an obvious extension: it is sometimes
said that `the left index varies quickest'.

C arrays are stored in \indexterm{row-major} order: elements in each
row are stored contiguous, and columns are then placed sequentially in
memory. A~$2\times2$ array \texttt{A[2][2]} is then stored as
\texttt{A[1][1], A[1][2], A[2][1], A[2][2]}. 

A number of remarks about arrays in~C.
\begin{itemize}
\item C (before the C99 standard) has multi-dimensional arrays only in
  a limited sense. You can declare them, but if you pass them to another
  C function, they no longer look multi-dimensional: they have become
  plain \texttt{float*} (or whatever type) arrays. That brings us to
  the next point.
\item Multi-dimensional arrays in C look as if they have type
  \texttt{float**}, that is, an array of pointers that point to
  (separately allocated) arrays for the rows. While you could
  certainly implement this:
\begin{verbatim}
float **A;
A = (float**)malloc(m*sizeof(float*));
for (i=0; i<n; i++)
  A[i] = (float*)malloc(n*sizeof(float));
\end{verbatim}
  careful reading of the standard reveals that a multi-dimensional
  array is in fact a single block of memory, no further pointers
  involved.
\end{itemize}
Given the above limitation on passing multi-dimensional arrays, and
the fact that a C~routine can not tell whether it's called from
Fortran or~C, it is best not to bother with multi-dimensional arrays
in C, and to emulate them:
\begin{verbatim}
float *A;
A = (float*)malloc(m*n*sizeof(float));
#define SUB(i,j,m,n) i+j*m
for (i=0; i<m; i++)
  for (j=0; j<n; j++)
    .... A[SUB(i,j,m,n)] ....
\end{verbatim}
where for interoperability we store the elements in column-major fashion.

\Level 0 {Strings}

Programming languages differ widely in how they handle strings. 
\begin{itemize}
\item In C, a string is an array of characters; the end of the string
  is indicated by a null character, that is the ascii character zero,
  which has an all zero bit pattern. This is called \indexterm{null
    termination}.
\item In Fortran, a string is an array of characters. The length is
  maintained in a internal variable, which is passed as a hidden
  parameter to subroutines.
\item In Pascal, a string is an array with an integer denoting the
  length in the first position. Since only one byte is used for this,
  strings can not be longer than 255 characters in Pascal.
\end{itemize}
As you can see, passing strings between different languages is fraught
with peril. This situation is made even worse by the fact that passing
strings as subroutine arguments is not standard.

Unless you are writing a text processor, it is therefore best not to
use strings in your program. The next best solution is to use
null-terminated strings throughout; some compilers support extensions
to facilitate this, for instance writing
\begin{verbatim}
DATA forstring /'This is a null-terminated string.'C/
\end{verbatim}

Recently, the `C/Fortran interoperability standard' has
provided a systematic solution to this.

\Level 0 {Subprogram arguments}

In C, you pass a \texttt{float} argument to a function if the function
needs its value, and \texttt{float*} if the function has to modify the
value of the variable in the calling environment. Fortran has no such
distinction: every variable is passed \indexterm{by reference}. This
has some strange consequences: if you pass a literal value
(\texttt{37.5}) to a subroutine, the compiler will allocate a nameless
variable with that value, and pass the address of it, rather than the
value\footnote{With a bit of cleverness and the right compiler, you
  can have a program that says \texttt{print *,7} and
  prints~\texttt{8} because of this.}.

For interfacing Fortran and C routines, this means that a Fortran
routine looks to a C~program like all its argument are `star'
arguments. Conversely, if you want a C subprogram to be callable from
Fortran, all its arguments have to be star-this or that. This means on
the one hand that you will sometimes pass a variable by reference that
you would like to pass by value.

Worse, it means that C subprograms like
\begin{verbatim}
void mysub(int **iarray) {
 *iarray = (int*)malloc(8*sizeof(int));
 return;
}
\end{verbatim}
can not be called from Fortran. There is a hack to get around this
(check out the Fortran77 interface to the Petsc routine
\texttt{VecGetValues}) and with more cleverness you can use
\texttt{POINTER} variables for this.

\Level 0 {Linker conventions}

As explained above, a compiler turns a source file into a binary,
which no longer has any trace of the source language: it contains in
effect functions in machine language. The linker will then match up
calls and definitions, which can be in different files. The problem
with using multiple languages is then that compilers have different
notions of how to translate function names from the source file to the
binary file.

The most common case of language interoperability is between C and
Fortran. The problems are platform dependent, but commonly
\begin{itemize}
\item The Fortran compiler attaches a trailing underscore to function
  names in the object file.
\item The C compiler takes the function name as it is in the source.
\end{itemize}
Since C is a popular language to write libraries in, this means we can
solve the problem by either
\begin{itemize}
\item Appending an underscore to all C function names; or
\item Include a simple wrapper call:
\begin{verbatim}
int SomeCFunction(int i,float f)
{
  .....
}
int SomeCFunction_(int i,float f)
{
  return SomeCFunction(i,f);
}
\end{verbatim}
\end{itemize}

With the latest Fortran standard it is possible to declare the
external name of variables and routines:
\begin{verbatim}
%% cat t.f
module operator
  real, bind(C) :: x
contains
  subroutine s(), bind(C,name='_s')
  return
  end subroutine
  ...
end module
%% ifort -c t.f
%% nm t.o
.... T _s
.... C _x
\end{verbatim}

It is also possible to declare data types to be C-compatible:
\begin{verbatim}
  type, bind(C) :: c_comp
    real (c_float)  :: data
    integer (c_int) :: i
    type (c_ptr)    :: ptr
  end type
\end{verbatim}
\Level 0 {Input/output}

Both languages have their own system for handling input/output, and it
is not really possible to meet in the middle. Basically, if Fortran
routines do I/O, the main program has to be in Fortran. Consequently,
it is best to isolate I/O as much as possible, and use C for I/O in
mixed language programming.

\Level 0 {Fortran/C interoperability in Fortran2003}

The latest version of Fortran, unsupported by many compilers at this
time, has mechanisms for interfacing to~C.
\begin{itemize}
\item There is a module that contains named kinds, so that one can declare
\begin{verbatim}
INTEGER,KIND(C_SHORT) :: i
\end{verbatim}
\item Fortran pointers are more complicated objects, so passing them
  to~C is hard; Fortran2003 has a mechanism to deal with C~pointers,
  which are just addresses.
\item Fortran derived types can be made compatible with C~structures.
\end{itemize}
