%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%
%%%% This text file is part of the source of 
%%%% `Introduction to High-Performance Scientific Computing'
%%%% by Victor Eijkhout, copyright 2012-7
%%%%
%%%% This book is distributed under a Creative Commons Attribution 3.0
%%%% Unported (CC BY 3.0) license and made possible by funding from
%%%% The Saylor Foundation \url{http://www.saylor.org}.
%%%%
%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In the theory part of this book you learned mathematical models can be
translated to algorithms that can be realized efficiently on modern
hardware. You learned how data structures and coding decisions
influence the performance of your code. In other words, you should now
have all the tools to write programs that solve scientific problems.

This would be all you would need to know,
if there was any guarantee that a correctly derived algorithm and
well designed data structure could immediately be turned into a
correct program.
Unfortunately, there is more to programming than that. This collection
of tutorials will give you the tools to be an effective scientific
programmer.

The vast majority of
scientific programming is done on the Unix platform so we start out
with a tutorial on Unix in chapter~\ref{tut:unix}, followed by an
explanation of the how your code is handled by compilers and linkers
and such in chapter~\ref{tut:compile}.

Next you will learn about some tools that will increase your
productivity and effectiveness: 
\begin{itemize}
\item The \emph{Make} utility is used for managing the building of
  projects; chapter~\ref{tut:gnumake}.
\item Source control systems store your code in such a way that you
  can undo changes, or maintain multiple versions; in
  chapter~\ref{tut:svn} you will see the \emph{subversion} software.
\item Storing and exchanging scientific data becomes an important
  matter once your program starts to produce results; in
  chapter~\ref{tut:hdf5} you will learn the use of \emph{HDF5}.
\item A lot of functionality that you need has been coded already by
  other people; in chapter~\ref{tut:petsc} you will learn about some
  of the scientific libraries that are available to you.
\item Visual output of program data is important, but too wide a topic
  to discuss here in great detail; chapter~\ref{tut:gnuplot} teaches
  you the basics of the \emph{gnuplot} package, which is suitable for
  simple data plotting.
\end{itemize}

We also consider the activity of program development itself:
chapter~\ref{tut:coding} considers how to code to prevent errors, and
chapter~\ref{tut:debug} teaches you to debug code with
\emph{gdb}. 
\begin{notready}
Chapter~\ref{tut:performance} discusses measuring the
performance of code.
\end{notready}
Chapter~\ref{tut:language} contains some information on
how to write a program that uses more than one programming language.

Finally, chapter~\ref{tut:latex} teaches you about the \LaTeX{}
document system, so that you can report on your work in beautifully
typeset articles.

Many of the tutorials are very hands-on. Do them while sitting at a
computer!
